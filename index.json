[{"content":" Year 2009 Version #In year 2009, Facebook used to be quite a different place than what it is today. Back then, only a handful of us from the then younger generation used to have Facebook accounts. We would take \u0026ldquo;What\u0026rsquo;s on your mind, Jatin?\u0026rdquo; prompt literally and share all our thoughts without worrying about accuracy or fear of being judged by others.\nOver the years, the use of Facebook as a medium to socialize has declined. I think any social network that is based on people connections is liable to become outdated as its users age. When young generations see their uncles and aunts on the network, they do not feel comfortable being their true selves‚Äîthe cool personality they showcase in front of their friends and peers, and so they seek out a platform with more youthful demographics. An exception to this trend is LinkedIn, where user profiles and activities rarely match with their true identities.\nComing back to the main topic, I remember my friend posted a few images of fractal trees generated with Python in October 2009. In its response, I decided to create Barnsley fern using Python and shared my image along with the code. I cannot recall all the details now, but I suspect that I must have referred to the pseudocode on Wikipedia page as my code matches it to some extent. However, I would still like to take credit for the color scheme as it took many trials and errors to arrive at it. You can check out my code here\nYear 2009 Version (Revised) #As I was writing this blog post, I realized that I could make a few minor adjustments to the original program to address some obvious issue and output a better quality image. The new program also takes less time to execute. Please find the revised code here. However, also note that the later sections in the article are still referring to the original version from 2009.\nYear 2024 Version #Fast forward to October 2024, and Facebook reminded me of my post as a 15-year-old ‚Äúmemory‚Äù and I re-shared it with my friends. There I had a thought that while I was very proud of my creation in 2009, it did not live up to the 2024-standards where we are spoilt by HD images surrounding us everywhere. The main stem of the fern was pencil-thin, and dots used to create the image were unevenly distributed, leaving some areas empty, causing it to fail to resemble a real fern.\nHence, to improve over the previous version, I set out to code a new program from scratch with the following changes in mind.\nUsing Polygons #Instead of beginning with a single point, I went for a polygon to directly draw the first segment of the main stem. This allowed me to assign the desired thickness to the stem and reduce the number of required fractal transformations from four to three. This, in effect, improved the time-complexity of the algorithm from \\(4^n\\) to \\(3^n\\), where \\(n\\) is the desired number of iterative transformations that we wish to apply. The deeper we iterate, the finer is the quality of the final image.\nDeterministic Algorithm #To keep the computation in check, the earlier program used random numbers to iteratively pick one among the four transformations and apply them instead of trying every combination, which would be as high as \\(4^{20}\\). I thought that we could avoid the random component and hence, I replaced it with a deterministic algorithm.\nUnbounded Iterations #With every transformation, we end up reducing the size of the polygon. Hence, I decided to apply these iterative tranformations indefinitely until the polygon\u0026rsquo;s size fell below a certain threshold, at which point I would exit that iteration. To find the size of the transformed polygon, I just multiplied the area of previous polygon by the scaling factor of the transformation. I recalled the learning from 3Blue1Brown Youtube video on determinants, which explained how the determinants and scale factors are related. I calculated the determinants of the three transformation matrices and hardcoded these values into the program. This approach allowed me to draw the entire fern without missing any portions and prevented unnecessary iterations that could have resulted in miniscule polygons.\nDespite the above changes, I wanted to retain the essence of the original design, and hence tried to keep the image dimension, position and color scheme consistent. The color scheme could not be matched exactly though since the iteration paths in the two programs were different. Here‚Äôs how the fern looks like now. You can find the updated code here.\nWhat\u0026rsquo;s Next #This concludes my exploration of the Bransley Fern images. I had initially planned to include my work on the Barnsley Fern fractal animations in here, and share a few animation videos with interesting zoom effects. However, to keep things short, I am saving that discussion for a separate article. Thanks for reading all the way to the end!\n","date":"November 11, 2024","permalink":"/posts/barnsley-fern-1/","section":"Posts","summary":"Exploring the beauty of my favorite fractal pattern.","title":"Barnsley Fern - Part 1"},{"content":"","date":null,"permalink":"/tags/fractal/","section":"Tags","summary":"","title":"Fractal"},{"content":"","date":null,"permalink":"/tags/mathematics/","section":"Tags","summary":"","title":"Mathematics"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"Welcome to my website! I\u0026rsquo;m really happy you stopped by.\n","date":null,"permalink":"/","section":"Welcome!","summary":"","title":"Welcome!"},{"content":" When I first entered school, I viewed numbers as mere collections of digits‚Äînothing more. Take, for instance, the number:\n$$ 42 $$\nHowever, my perspective got quickly changed when I first learned about the negative numbers. Many of us as children must have once stumbled upon a subtraction like \\(3 - 5\\) and imagined what its result should be. Unlike fractions and percentages, we haven\u0026rsquo;t adopted negative numbers in our everyday conversation. If someone asks, \u0026ldquo;How much older are you than your friend?\u0026rdquo; then responding with \u0026ldquo;Negative six months\u0026rdquo; would sound odd. A more acceptable reply would be, \u0026ldquo;I\u0026rsquo;m actually six months younger.\u0026rdquo;\nNegative numbers revealed that positive values were just one side of the coin. To denote a negative number, we place a minus sign (\\(‚àí\\)) in front of the value. For positive numbers, we can can use the plus sign (\\(+\\)) to be specific, but we often omit it, treating the unsigned numbers as positive by default.\n$$ +42 $$\nNext, I was introduced to fractions, which expanded my horizon beyond whole numbers. It made me realize the importance of having a system that deals with partial values. A fraction like \\( \\frac{3}{5} \\) signifies three parts of \u0026ldquo;one-fifth.\u0026rdquo; In this sense, every whole number is also a fraction with denominator \\(1\\).\n$$ \\frac{42}{1} $$\nSoon after, I discovered decimal numbers. This let me view finite numbers as an infinite sequence of digits, with zeros extending in both directions. We use the decimal point (\\(.\\)) to fixate decimal numbers and the place value of digits are determined by their positions relative to this point.\nDecimal point plays a crucial role when perfoming hand-calculations on paper. Whether it\u0026rsquo;s addition, subtraction, multiplication, division or finding square-root using long-division method, we always vertically align the initial, intermediate and resultant terms using their decimal points as reference.\nFor the sake of brevity, we typically trim leading and trailing zeros, allowing us to express \\(0042.4200\\) simply as \\(42.42\\). We follow a couple of rules here: if all digits before the decimal are zero, we keep the last one, turning \\(0000.42\\) into \\(0.42\\). If all digits after the decimal are zero, we discard them along with the decimal point, so \\(42.0000\\) becomes \\(42\\).\n$$ \u0026hellip;00042.000\u0026hellip; $$\nIn high school, I encountered scientific notation for expressing very large or small numbers. The first example that struck me was Avogadro\u0026rsquo;s number: \\(6.022 \\times 10^{23}\\), which is roughly the number of atoms present in one gram of hydrogen. Scientific notation simplifies calculations, especially in scientific formulas involving multiplication and division. For instance, \\((a_1 \\times 10^{b_1}) \\times (a_2 \\times 10^{b_2})\\) simplifies to \\(a_1 \\times a_2 \\times 10^{b_1 + b_2}\\), which is less error-prone than multiplying their decimal representations and ensuring that decimal point is correctly placed in the result.\n$$ 4.2 \\times 10^{1} $$\nAfter tenth grade, my parents enrolled me in computer classes to familiarize me with technology. It was the year 1998, and MS-DOS and Windows 95 were the primary operating systems. Next to my classroom, there were advanced computer classes held for people older than me. One day, when all classes were over and after doing an overtime on the game of Solitaire, I passed by the advanced classroom. I noticed a table drawn on the blackboard listing numbers from 0 to 15 on one side and figures 0000 to 1111 on the other. It made no sense at first, so I kept staring until I could draw the pattern out of zeros and ones, and there I had the first mind-blown experience in my life.\nIt never crossed my mind that the ten symbols we use for numbers are merely a choice, not a mathematical necessity. We could just as easily use a different number of symbols, or in other words, a different base system and all the arithmetic methods we developed had remain unchanged. To denote a number with its base, we write it in parentheses with the base as a subscript, like \\((52)_8\\). If the base is not specified, it is assumed to be 10, which is the most common base system.\n$$ (42)_{10} $$\nMy first year of engineering introduced me to complex numbers, which consist of a real part and an imaginary part. These numbers are essential in fields like engineering and physics. They often appear in intermediate calculations and we typically pick the real component in the final result. In these contexts, we treat all real numbers as complex numbers with an imaginary part of zero.\n$$ 42 + 0i $$\nFinally, while studying matrices, I realized I had only been working with single values until then, whereas matrices lets us represent multitude of values. In fact, any number can be viewed as a 1x1 matrix, and all matrix operations‚Äîsuch as addition, multiplication, finding determinants, or inverses‚Äîyield expected results.\n$$ \\begin{bmatrix} 42 \\end{bmatrix} $$\nAnd so concludes my journey through the world of numbers‚Äîunless I\u0026rsquo;ve overlooked something. I could have touched on exponents (\\(42^1\\)) or derivatives (\\(d^042/dx^0\\)), but I feel they don\u0026rsquo;t quite fit here. Thank you for reading!\n","date":"November 07, 2024","permalink":"/posts/what-is-number/","section":"Posts","summary":"How my perception of innocent-looking numbers evolved over time.","title":"What is a Number?"},{"content":"","date":null,"permalink":"/tags/c%23/","section":"Tags","summary":"","title":"C#"},{"content":" To support SQL-like LINQ query expressions in C# 3.0, several language features were introduced, including lambda expressions, extension methods, and anonymous types. While the query expressions themselves did not become mainstream, the supporting features gained significant popularity. Building on the success of lambda syntax, C# 6.0 introduced expression-bodied members, which were further enhanced in C# 7.0 and C# 8.0 to support all possible class and struct member types.\nConsider the following example of a property definition and its replacement using expression-body syntax:\n// Traditional Syntax. public string Address { get { return this.address; } set { this.address = value; } } // Expression-Body Syntax. public string Address { get =\u0026gt; this.address; set =\u0026gt; this.address = value; } If the Address property above does not have a setter, the property definition can be further simplified to:\npublic string Address =\u0026gt; this.address; Constructors and methods can also utilize the shorthand syntax provided by expression-bodied members:\n// Traditional Syntax. public Person(string name) // Constructor. { this.Name = name; } public string GetName() // Method. { return this.FirstName + \u0026#34; \u0026#34; + this.LastName; } // Expression-Body Syntax. public Person(string name) =\u0026gt; this.Name = name; // Constructor. public string GetName() =\u0026gt; this.FirstName + \u0026#34; \u0026#34; + this.LastName; // Method. While the expression-body syntax can make your code more concise, there are some considerations to keep in mind. Unlike lambda functions, which can have multiple statements as in num =\u0026gt; { int digit = (num / 10) % 10; return digit * digit; }, the expression-bodied members are limited to single expression only, and using expression-body syntax for single-statement methods and the regular one for multi-statement methods will make your code appear incoherent.\nAdditionally, developers who embrace the functional programming style often view expressions as statements with no side effects. In the above code examples, the getter-only Address property and the GetName method do not alter the state of containing class, so it may be reasonable to use the expression-body syntax for them. However, for the same reason, a regular method-body syntax will be more preferable for the single-statement Person constructor.\n","date":"October 19, 2024","permalink":"/posts/expression-bodied-members/","section":"Posts","summary":"C# syntactic sugar series - Part 4.","title":"C# Expression Body Syntax"},{"content":"","date":null,"permalink":"/tags/syntactic-sugar-series/","section":"Tags","summary":"","title":"Syntactic Sugar Series"},{"content":" Before C# included support for tuples, the traditional approach to returning multiple values from a method was to define out method parameters. This method allowed developers to return additional values without creating custom data structures. For example, consider the TryParse method in the Int32 struct:\npublic struct Int32 { public static bool TryParse(string? s, out int result); } A typical caller of this method would look like:\nint number; if (int.TryParse(\u0026#34;42\u0026#34;, out number)) { DoSomething(number); } C# 7.0 introduced a shorthand for inlining the out variable declarations, simplifying the syntax and improving code readability. Now, you can write:\nif (int.TryParse(\u0026#34;42\u0026#34;, out int number)) { DoSomething(number); } In the above example, the scope of the variable number is same as the scope inside which TryParse method is called. This allows you to refer to the number outside the if-block as well.\nTraditionally, to check for the variable\u0026rsquo;s underlying type, one had to use the as operator followed by a null-check as in the following code:\nint number = obj as int; if (number != null) { DoSomething(number); } C# 7.0 also added support for the is operator to check for the variable\u0026rsquo;s type that eliminated the null-check as follows:\nif (obj is int) { int number = (int)obj; DoSomething(number); } By inlining the declaration of variable number similar to that for out variables, we can further modify the previous code with a more succinct version:\nif (obj is int number) { DoSomething(number); } The above support falls under a broader class of syntactic sugars called \u0026lsquo;Pattern Matching\u0026rsquo;, introduced in C# 7 and further enhanced in C# 8. Pattern matching allows developers to perform complex type checks and comparisons in a more readable and concise manner. It includes features like type patterns, constant patterns, and positional patterns, which we shall cover piecewise in future posts.\n","date":"October 12, 2024","permalink":"/posts/inlined-variable-declaration/","section":"Posts","summary":"C# syntactic sugar series - Part 3.","title":"C# Inlined Variable Declaration"},{"content":" If you\u0026rsquo;ve been programming in C# for a while, you\u0026rsquo;re likely familiar with the object initializer syntax that simplifies the process of creating and initializing objects. Consider the following class definition:\nclass Person { public string FirstName { get; set; } public string LastName { get; set; } } With this class, you can initialize an object in two ways. The traditional method involves creating an instance and then setting properties individually:\nPerson person = new Person(); person.FirstName = \u0026#34;John\u0026#34;; person.LastName = \u0026#34;Doe\u0026#34;; However, C# allows for a more concise approach using object initializers:\nPerson person = new Person { FirstName = \u0026#34;John\u0026#34;, LastName = \u0026#34;Doe\u0026#34;, }; In the example above, initializing the properties FirstName and LastName is optional. You can instantiate the object with new Person() without providing values for these properties, and the compiler will allow it, which is not always desirable. To enforce that a property must be initialized during object creation, you can use the required modifier introduced in C# 11:\npublic required string FirstName { get; set; } With this definition, attempting to create a Person object without setting FirstName will result in a compilation error:\n// This will fail. Person person = new Person { LastName = \u0026#34;Doe\u0026#34; }; If you want to ensure that FirstName is set during initialization and cannot be changed afterward, you can define the property with the init accessor:\npublic string FirstName { get; init; } I would recommend this approach as it allows you to create immutable class-objects whose state cannot change after they are constructed.\nImmutability is a powerful concept in software design. By defining classes as immutable, you can avoid many common bugs related to state changes, especially in multi-threaded environments. While it may seem restrictive, it often leads to cleaner and more maintainable code. In my experience, I\u0026rsquo;ve successfully built sizable server applications and tools with only immutable classes, and the benefits in terms of reliability and simplicity are significant.\nBefore the introduction of init, a common way to create immutable classes was to use readonly fields:\npublic readonly string FirstName; This approach necessitates passing the values as constructor arguments, which can result in lengthy constructor signatures when there are many fields to be initialized in the class. Additionally, to avoid modifying the existing method calls with the introduction of new fields, one might resort to creating multiple overloaded constructors with one invoking another. This complicates the code and makes it harder to read and maintain. The init accessor solves majority of these issues. The caller code can now pass the values in any order and does not need to match them with one of the constructor signatures.\nIn summary, by leveraging object initializers, the required modifier, and the init accessor, you can create robust and maintainable applications. Embracing immutability can lead to cleaner code and fewer issues in concurrent scenarios, making it a best practice worth adopting in your C# programming endeavors.\n","date":"October 05, 2024","permalink":"/posts/object_initializers/","section":"Posts","summary":"C# syntactic sugar series - Part 2.","title":"C# Object Initializers"},{"content":" C# as a language continues to evolve with new versions released every year. With the introduction of new language features, it can be challenging to stay up to date. This is the first post in a series where I will cover the new syntactic sugars incorporated in the recent versions of C#.\nA common task for C# developers is ensuring that classes are initialized with valid arguments. This often involves adding null checks in the class constructor, as illustrated below:\npublic Person(string firstName) { if (firstName is null) { throw new ArgumentNullException(nameof(firstName)); } this.firstName = firstName; } As you can see, it takes several lines of code to validate constructor parameters, which can be cumbersome. However, you can simply the validation code by using the null-coalescing operator ?? combined with a throw expression:\nthis.firstName = firstName ?? throw new ArgumentNullException(nameof(firstName)); While this reduces the code significantly, you still need to specify the parameter name for the ArgumentNullException, which helps in identifying the problematic argument from the exception message, such as Value cannot be null. (Parameter \u0026lsquo;firstName\u0026rsquo;).\nThe introduction of CallerArgumentExpression attribute in C# 10 allows for even more concise code. You can create a method like EnsureNotNull to simplify the null-check further:\nprivate string EnsureNotNull( string argument, [CallerArgumentExpression(nameof(argument))] string paramName = null) { if (argument is null) { throw new ArgumentNullException(paramName); } return argument; } this.firstName = this.EnsureNotNull(firstName); In the code sample, the compiler will inject string \u0026quot;firstName\u0026quot; as the value of paramName to EnsureNotNull method without requiring the caller to pass it explicitly. Hence, the exception message will contain the parameter name as firstName if the value of argument is null.\nThe above EnsureNotNull method is simplified to highlight the essentials of caller argument expressions. A real-world solution will possibly implement an extension method that accommodates nullable checks and works with any argument type:\ninternal static class EnsureExtensions { public static T EnsureNotNull\u0026lt;T\u0026gt;( [NotNull] this T? argument, [CallerArgumentExpression(nameof(argument))] string? paramName = null) { ArgumentNullException.ThrowIfNull(argument, paramName); return argument; } } this.firstName = firstName.EnsureNotNull(); If you prefer not to create custom methods or rely on third-party libraries, a straightforward two-liner solution is available using methods from the C# core library starting with .NET 6:\nArgumentNullException.ThrowIfNull(firstName); this.firstName = firstName; This approach not only simplifies your code but also enhances readability and maintainability, aligning with modern C# practices.\n","date":"October 02, 2024","permalink":"/posts/throw-expression/","section":"Posts","summary":"C# syntactic sugar series - Part 1.","title":"C# Throw Expression and Argument Expression"},{"content":"Background #My younger son studies in an online classroom, and last week was the time for their oral tests. As you might know, written tests are often not reliable indicators of student performance in an online setting, especially when it is India üôÇ The oral tests covered three subjects, each conducted on a separate day. Each day, the teacher would call students one at a time in a specific order to join her online and answer questions.\nThere were 31 students in the classroom. If the teacher had called the students by their roll numbers - from 1 to 31 - every day, those with higher roll numbers would always have to wait until the evening. To ensure that wait times were more evenly distributed, the teacher informed the parents that she would call students in the following order over the three days:\nDay 1: By roll numbers from 1 to 31. Day 2: By roll numbers from 31 to 1. Day 3: By roll numbers from 16 to 31, followed by 1 to 15. Upon hearing this, my immediate reaction was that this plan does not fully balance the wait times. For instance, the student with roll number 16 would wait for half the time on Days 1 and 2 but would not wait at all on Day 3. Conversely, the student with roll number 15 would experience nearly equal wait times on Days 1 and 2 but would have to wait until the end on Day 3. Thus, the wait times were not fairly distributed, and there might be a better arrangement that could produce a more even distribution of wait times across the three days.\nComparing Wait Time Distributions #A few days later, when my son\u0026rsquo;s oral tests began, I revisited this issue. Intuitively, I believed that the following arrangement would yield a better outcome than the teacher\u0026rsquo;s original plan:\nDay 1: By roll numbers from 1 to 31. Day 2: By roll numbers from 11 to 31, followed by 1 to 10. Day 3: By roll numbers from 21 to 31, followed by 1 to 20. It\u0026rsquo;s worth noting that the order for Day 1 can remain consistent, rolling from 1 to 31 regardless of the overall arrangement, without losing generality. For the sake of analysis, let\u0026rsquo;s assume that the first student called on any given day waits for 0 time-units, and this waiting time increases by 1 unit for each subsequent student, culminating in a wait time of 30 units for the last student of that day.\nWith the teacher\u0026rsquo;s arrangement,\nStudent with roll number 16 waits for (15 + 15 + 0) = 30 units. Student with roll number 17 waits for (16 + 14 + 1) = 31 units. Student with roll number 18 waits for (17 + 13 + 2) = 32 units. \u0026hellip; \u0026hellip; Student with roll number 13 waits for (12 + 18 + 28) = 58 units. Student with roll number 14 waits for (13 + 17 + 29) = 59 units. Student with roll number 15 waits for (14 + 16 + 30) = 60 units. Here\u0026rsquo;s how the wait times appear for each student:\nIn contrast, with the new arrangement I proposed,\nStudent with roll number 21 waits for (20 + 10 + 0) = 30 units. Student with roll number 11 waits for (10 + 0 + 21) = 31 units. Student with roll number 1 waits for (0 + 21 + 11) = 32 units. Student with roll number 22 waits for (21 + 11 + 1) = 33 units. \u0026hellip; \u0026hellip; Student with roll number 30 waits for (29 + 19 + 9) = 57 units. Student with roll number 20 waits for (19 + 9 + 30) = 58 units. Student with roll number 10 waits for (9 + 30 + 20) = 59 units. Student with roll number 31 waits for (30 + 20 + 10) = 60 units. Here\u0026rsquo;s how the new wait times look:\nUltimately, the new arrangement did not prove to be better or worse than the teacher\u0026rsquo;s plan; it merely redistributed the wait times among a different permutation of students.\nAfter some more scribbling on paper, I finally discovered an optimal arrangement. Take a look at the table below, which illustrates how the first and second halves of the roll numbers are interleaved on Day 3.\nDay 1 Sequence Day 2 Sequence Day 3 Sequence 1 17 16 2 18 31 3 19 15 4 20 30 5 21 14 6 22 29 \u0026hellip; \u0026hellip; \u0026hellip; 14 30 25 15 31 9 16 1 24 17 2 8 \u0026hellip; \u0026hellip; \u0026hellip; 30 15 17 31 16 1 To demonstrate that this arrangement is effective, here\u0026rsquo;s another table, this time ordered by roll numbers. Pay close attention to the differences in per-day wait times for successive students; this will give you a clearer understanding of how the arrangement achieves balanced wait times.\nRoll Number Day 1 Wait Time Day 2 Wait Time Day 3 Wait Time Total Wait Time 1 0 15 30 45 2 1 16 28 45 3 2 17 26 45 4 3 18 24 45 5 4 19 22 45 6 5 20 20 45 \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; 14 13 28 4 45 15 14 29 2 45 16 15 30 0 45 17 16 0 29 45 \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; 30 29 13 3 45 31 30 14 1 45 If the above table doesn\u0026rsquo;t clarify things, here\u0026rsquo;s a chart to help visualize the distribution of wait times.\nI also discovered a couple of other arrangements that provided balanced wait times. However, upon further inspection, it turned out that all of these could be derived by either shuffling the three days or rearranging the roll numbers. Essentially, there were no unique arrangements that could not be constructed by simply reordering the optimal arrangement mentioned above.\nGeneralizing the Solution #For an Arbitrary Number of Days #The challenge of arranging students arises only when the number of days is odd. If there were an even number of days, we could simply arrange students from start to end on every odd day and from end to start on the even days. Naturally, balancing wait times would be impossible with just a single day. However, for any odd number of days greater than one, we could start by arranging the students from start to end on every odd day, followed by end to start on the even days, continuing the pattern until we reach three days, at which point we could apply the same arrangement as described earlier.\nFor an Arbitrary Number of Students #Now, let\u0026rsquo;s consider the scenario where we have three days and an even number of students. Can we balance wait times for all students? Sadly, this is not possible and here is a brief explanation to convince you. Let\u0026rsquo;s denote the number of students as S. The wait times for students on a given day will progressively increase from 0 to S-1, averaging at (S-1)/2. Consequently, the three-day average would be 3(S-1)/2. If we assume there exists an arrangement that produces the same wait time for all students after three days, then the total wait time for each student would be equal the average wait time, which is 3(S-1)/2. This expression does not produce a whole number if S is even.\nBut let\u0026rsquo;s not lose hope. We can still achieve a near-balanced solution for an even number of students. We can create an arrangement where the total wait time is a whole number that is 0.5 above the value of 3(S-1)/2 for half of the students and is 0.5 below that value for the other half. The following table illustrates one such possible sequence for 6 students.\nDay 1 Sequence Day 2 Sequence Day 3 Sequence 1 4 3 2 5 6 3 6 2 4 1 5 5 2 1 6 3 4 And now the wait times ordered by the roll numbers.\nRoll Number Day 1 Wait Time Day 2 Wait Time Day 3 Wait Time Total Wait Time 1 0 3 4 7 2 1 4 2 7 3 2 5 0 7 4 3 0 5 8 5 4 1 3 8 6 5 2 1 8 Finally, for the sake of completeness, here\u0026rsquo;s a chart to visualize the above table.\nIn summary, the problem turned out to be far more challenging than I had anticipated. I realized that I could neither expect the teacher to find the solution nor the parents to remember the order if it were shared for their child. However, I made a couple of discoveries along the way, and I\u0026rsquo;m glad I spent time in tackling it.\n","date":"September 16, 2021","permalink":"/posts/wait-times/","section":"Posts","summary":"An arrangement that evenly distributes the waiting times for student in a classroom.","title":"Balancing the Wait Times"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]